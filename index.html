<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Map Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 40px;
            align-items: flex-start;
        }

        .left-panel {
            width: 400px;
            flex-shrink: 0;
        }

        .right-panel {
            flex: 1;
            min-height: 400px;
        }

        .header {
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .header p {
            font-size: 0.9rem;
            color: #666;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
            font-size: 0.9rem;
        }

        .color-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            font-size: 14px;
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
            background: #ffffff;
            text-transform: uppercase;
        }

        .color-input:focus {
            outline: none;
            border-color: #666;
        }

        .gradient-preview {
            height: 20px;
            border: 1px solid #ddd;
            margin-top: 8px;
            background: linear-gradient(to right, #000, #fff);
        }

        .help-text {
            margin-top: 8px;
            font-size: 0.8rem;
            color: #666;
            line-height: 1.4;
        }

        .actions {
            margin-top: 20px;
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: #ffffff;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            color: #333;
        }

        .btn:hover {
            background: #f5f5f5;
            border-color: #999;
        }

        .btn-primary {
            background: #333;
            color: white;
            border-color: #333;
        }

        .btn-primary:hover {
            background: #555;
            border-color: #555;
        }

        .upload-area {
            border: 2px dashed #ccc;
            padding: 60px 20px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            position: relative;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: #999;
            background: #f5f5f5;
        }

        .upload-area input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .upload-text {
            font-size: 1rem;
            color: #666;
            margin-bottom: 5px;
        }

        .upload-hint {
            color: #999;
            font-size: 0.85rem;
        }

        .image-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-container canvas {
            max-width: 100%;
            max-height: 80vh;
            cursor: pointer;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                gap: 30px;
            }
            
            .left-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <div class="header">
                <h1>Gradient Map Tool</h1>
                <p>Apply color gradients to images</p>
            </div>

            <div class="control-group">
                <label for="colorInput">Color Gradient</label>
                <input type="text" id="colorInput" class="color-input" placeholder="0F1113 2E3237-20 FF5019-68 DE9D50-79 C8C8C3-90 DEDEDB" value="0F1113 2E3237-20 FF5019-68 DE9D50-79 C8C8C3-90 DEDEDB">
                <div class="gradient-preview" id="gradientPreview"></div>
                <div class="help-text">
                    Enter colors separated by spaces or commas. Supports hex codes with or without #.<br>
                    Add custom stops with -percentage: <strong>FF00FF-25</strong> places pink at 25%
                </div>
            </div>

            <div class="actions">
                <button class="btn btn-primary" id="saveBtn">Save Image</button>
                <button class="btn" id="copyBtn">Copy to Clipboard</button>
            </div>
        </div>

        <div class="right-panel">
            <div class="upload-area" id="uploadArea">
                <input type="file" id="fileInput" accept="image/*">
                <div class="upload-text">Drop an image here or click to browse</div>
                <div class="upload-hint">Supports JPG, PNG, GIF, and more</div>
            </div>
            
            <div class="image-container" id="imageContainer">
                <!-- Image will be displayed here -->
            </div>
        </div>
    </div>

    <script>
        class GradientMapTool {
            constructor() {
                this.originalCanvas = null;
                this.processedCanvas = null;
                this.originalImage = null;
                this.gradientStops = [];
                this.copyTimeout = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.loadFromURL();
            }

            initializeElements() {
                this.colorInput = document.getElementById('colorInput');
                this.gradientPreview = document.getElementById('gradientPreview');
                this.fileInput = document.getElementById('fileInput');
                this.uploadArea = document.getElementById('uploadArea');
                this.imageContainer = document.getElementById('imageContainer');
                this.saveBtn = document.getElementById('saveBtn');
                this.copyBtn = document.getElementById('copyBtn');
            }

            setupEventListeners() {
                this.colorInput.addEventListener('input', () => this.updateGradient());
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                this.saveBtn.addEventListener('click', () => this.saveImage());
                this.copyBtn.addEventListener('click', () => this.copyToClipboard());
                this.setupDragAndDrop();
                this.setupKeyboardShortcuts();
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Ctrl+V or Cmd+V when not focused on input
                    if ((e.ctrlKey || e.metaKey) && e.key === 'v' && document.activeElement !== this.colorInput) {
                        e.preventDefault();
                        this.handlePaste();
                    }
                });
            }

            async handlePaste() {
                try {
                    const items = await navigator.clipboard.read();
                    for (const item of items) {
                        if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                            const blob = await item.getType(item.types.find(type => type.startsWith('image/')));
                            const url = URL.createObjectURL(blob);
                            const img = new Image();
                            img.onload = () => {
                                this.originalImage = img;
                                this.createCanvas();
                                this.applyGradientMap();
                                URL.revokeObjectURL(url);
                            };
                            img.src = url;
                            break;
                        }
                    }
                } catch (err) {
                    console.log('Clipboard access not available or no image in clipboard');
                }
            }

            setupDragAndDrop() {
                const dropZones = [this.uploadArea, this.imageContainer];
                
                dropZones.forEach(zone => {
                    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                        zone.addEventListener(eventName, (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                        });
                    });

                    ['dragenter', 'dragover'].forEach(eventName => {
                        zone.addEventListener(eventName, () => {
                            if (zone === this.uploadArea) {
                                zone.classList.add('dragover');
                            }
                        });
                    });

                    ['dragleave', 'drop'].forEach(eventName => {
                        zone.addEventListener(eventName, () => {
                            if (zone === this.uploadArea) {
                                zone.classList.remove('dragover');
                            }
                        });
                    });

                    zone.addEventListener('drop', (e) => {
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            this.handleFile(files[0]);
                        }
                    });
                });
            }

            parseColorInput(input) {
                const colors = input.split(/[,\s]+/).filter(c => c.trim());
                const stops = [];
                
                colors.forEach((color, index) => {
                    let hexColor = color.trim().toUpperCase();
                    let position = null;
                    
                    // Check for custom position
                    if (hexColor.includes('-')) {
                        const parts = hexColor.split('-');
                        hexColor = parts[0];
                        position = parseInt(parts[1]) / 100;
                    }
                    
                    // Add # if missing
                    if (!hexColor.startsWith('#')) {
                        hexColor = '#' + hexColor;
                    }
                    
                    // Validate hex color
                    if (/^#[0-9A-F]{6}$/i.test(hexColor)) {
                        if (position === null) {
                            position = colors.length > 1 ? index / (colors.length - 1) : 0;
                        }
                        stops.push({ color: hexColor, position: Math.max(0, Math.min(1, position)) });
                    }
                });
                
                // Sort by position
                stops.sort((a, b) => a.position - b.position);
                return stops;
            }

            updateGradient() {
                this.gradientStops = this.parseColorInput(this.colorInput.value);
                this.updateGradientPreview();
                this.updateURL();
                
                if (this.originalImage) {
                    this.applyGradientMap();
                }
            }

            updateGradientPreview() {
                if (this.gradientStops.length === 0) {
                    this.gradientPreview.style.background = '#ccc';
                    return;
                }
                
                const gradientString = this.gradientStops
                    .map(stop => `${stop.color} ${stop.position * 100}%`)
                    .join(', ');
                
                this.gradientPreview.style.background = `linear-gradient(to right, ${gradientString})`;
            }

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    this.handleFile(file);
                }
            }

            handleFile(file) {
                if (!file.type.startsWith('image/')) {
                    alert('Please select an image file.');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        this.createCanvas();
                        this.applyGradientMap();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            createCanvas() {
                // Hide upload area and show image container
                this.uploadArea.style.display = 'none';
                this.imageContainer.style.display = 'flex';
                
                // Create processed canvas
                this.processedCanvas = document.createElement('canvas');
                this.processedCanvas.width = this.originalImage.width;
                this.processedCanvas.height = this.originalImage.height;
                
                // Make canvas clickable to change image
                this.processedCanvas.addEventListener('click', () => {
                    this.fileInput.click();
                });
                
                // Create original canvas for processing (hidden)
                this.originalCanvas = document.createElement('canvas');
                this.originalCanvas.width = this.originalImage.width;
                this.originalCanvas.height = this.originalImage.height;
                
                const originalCtx = this.originalCanvas.getContext('2d');
                originalCtx.drawImage(this.originalImage, 0, 0);
                
                // Clear and add processed canvas
                this.imageContainer.innerHTML = '';
                this.imageContainer.appendChild(this.processedCanvas);
                
                // Add context menu for right-click save
                this.processedCanvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.saveImage();
                });
            }

            applyGradientMap() {
                if (!this.originalImage || !this.processedCanvas || this.gradientStops.length === 0) {
                    return;
                }
                
                const ctx = this.processedCanvas.getContext('2d');
                const originalCtx = this.originalCanvas.getContext('2d');
                
                // Get original image data
                const imageData = originalCtx.getImageData(0, 0, this.originalCanvas.width, this.originalCanvas.height);
                const data = imageData.data;
                
                // Create gradient lookup table
                const gradientLUT = this.createGradientLUT();
                
                // Apply gradient map
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Calculate luminance
                    const luminance = Math.round((0.299 * r + 0.587 * g + 0.114 * b));
                    
                    // Get gradient color
                    const gradientColor = gradientLUT[luminance];
                    
                    data[i] = gradientColor.r;
                    data[i + 1] = gradientColor.g;
                    data[i + 2] = gradientColor.b;
                    // Alpha remains unchanged
                }
                
                // Draw processed image
                ctx.putImageData(imageData, 0, 0);
            }

            createGradientLUT() {
                const lut = new Array(256);
                
                for (let i = 0; i < 256; i++) {
                    const position = i / 255;
                    lut[i] = this.getGradientColor(position);
                }
                
                return lut;
            }

            getGradientColor(position) {
                if (this.gradientStops.length === 0) {
                    return { r: 0, g: 0, b: 0 };
                }
                
                if (this.gradientStops.length === 1) {
                    return this.hexToRgb(this.gradientStops[0].color);
                }
                
                // Find the two stops to interpolate between
                let leftStop = this.gradientStops[0];
                let rightStop = this.gradientStops[this.gradientStops.length - 1];
                
                for (let i = 0; i < this.gradientStops.length - 1; i++) {
                    if (position >= this.gradientStops[i].position && position <= this.gradientStops[i + 1].position) {
                        leftStop = this.gradientStops[i];
                        rightStop = this.gradientStops[i + 1];
                        break;
                    }
                }
                
                // Interpolate between the two stops
                const leftColor = this.hexToRgb(leftStop.color);
                const rightColor = this.hexToRgb(rightStop.color);
                
                const range = rightStop.position - leftStop.position;
                const factor = range === 0 ? 0 : (position - leftStop.position) / range;
                
                return {
                    r: Math.round(leftColor.r + (rightColor.r - leftColor.r) * factor),
                    g: Math.round(leftColor.g + (rightColor.g - leftColor.g) * factor),
                    b: Math.round(leftColor.b + (rightColor.b - leftColor.b) * factor)
                };
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            saveImage() {
                if (!this.processedCanvas) return;
                
                this.processedCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'gradient-mapped-image.png';
                    a.click();
                    URL.revokeObjectURL(url);
                });
            }

            copyToClipboard() {
                if (!this.processedCanvas) return;
                
                const originalText = this.copyBtn.textContent;
                
                this.processedCanvas.toBlob((blob) => {
                    const item = new ClipboardItem({ 'image/png': blob });
                    navigator.clipboard.write([item]).then(() => {
                        this.copyBtn.textContent = 'Copied!';
                        
                        if (this.copyTimeout) {
                            clearTimeout(this.copyTimeout);
                        }
                        
                        this.copyTimeout = setTimeout(() => {
                            this.copyBtn.textContent = originalText;
                        }, 2000);
                    }).catch(() => {
                        this.copyBtn.textContent = 'Copy Failed';
                        
                        if (this.copyTimeout) {
                            clearTimeout(this.copyTimeout);
                        }
                        
                        this.copyTimeout = setTimeout(() => {
                            this.copyBtn.textContent = originalText;
                        }, 2000);
                    });
                });
            }

            updateURL() {
                // Use hash-based URL to work in all contexts including artifacts
                const colors = encodeURIComponent(this.colorInput.value);
                if (typeof window !== 'undefined' && window.location) {
                    window.location.hash = `colors=${colors}`;
                }
            }

            loadFromURL() {
                try {
                    // Try to load from hash first (works in artifacts)
                    if (window.location.hash) {
                        const hashParams = new URLSearchParams(window.location.hash.slice(1));
                        const colors = hashParams.get('colors');
                        if (colors) {
                            this.colorInput.value = decodeURIComponent(colors);
                            this.updateGradient();
                            return;
                        }
                    }
                    
                    // Fall back to search params (works when hosted normally)
                    const params = new URLSearchParams(window.location.search);
                    const colors = params.get('colors');
                    if (colors) {
                        this.colorInput.value = decodeURIComponent(colors);
                    }
                } catch (e) {
                    console.log('URL loading not available in this context');
                }
                
                this.updateGradient();
            }
        }

        // Initialize the tool when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new GradientMapTool();
        });
    </script>
</body>
</html>